import {
  IncomingRequest,
  ResponseOutparam,
  OutgoingBody,
  OutgoingResponse,
  Fields,
} from 'wasi:http/types@0.2.0';
//@ts-expect-error -- these types aren't currently generated by JCO
import { log } from 'wasi:logging/logging';
//@ts-expect-error -- these types aren't currently generated by JCO
import { increment } from 'wasi:keyvalue/atomics@0.2.0-draft';
// @ts-expect-error -- these types aren't currently generated by JCO
import { open } from 'wasi:keyvalue/store@0.2.0-draft';

async function initializeStore() {
  return await open('default');
}

async function handle(req: IncomingRequest, resp: ResponseOutparam) {
  // Start building an outgoing response
  const outgoingResponse = new OutgoingResponse(new Fields());

  let outgoingBody = outgoingResponse.body();
  const pathWithQuery = req.pathWithQuery();
  if (!pathWithQuery) {
    return respondWithError(outgoingResponse, resp, 'Invalid request: pathWithQuery is empty');
  }

  const params = getParamsFromPath(pathWithQuery);
  const value = params['value'];
  const key = params['key'];

  if (!value) {
    return respondWithError(outgoingResponse, resp, 'Invalid request: function is not specified');
  }

  log('info', '', `Greeting key ${key}`);

  try {
    const kv = await initializeStore();


    // const newvalue = new Uint8Array([0x48, 0x65, 0x6C, 0x6C, 0x6F]); // Hello
    const encoder = new TextEncoder();
    const newvalue = encoder.encode(value);

    kv.set(key, newvalue);// increment(kv, name, 1);




    const mydata = kv.get(key)
    // Create a stream for the response body
    let outputStream = outgoingBody.write();
    // Write hello world to the response stream
    outputStream.blockingWriteAndFlush(
      new Uint8Array(new TextEncoder().encode(`Hello x${mydata}, ${key}!\n`)),
    );
    // @ts-ignore: This is required in order to dispose the stream before we return
    outputStream[Symbol.dispose]();

    // Set the status code for the response
    outgoingResponse.setStatusCode(200);
    // Finish the response body
    OutgoingBody.finish(outgoingBody, undefined);
    // Set the created response
    ResponseOutparam.set(resp, { tag: 'ok', val: outgoingResponse });
    log('info', 'handle', 'Response sent successfully.');
  } catch (error) {
    log('error', 'handle', `Error handling request: ${error}`);
    respondWithError(outgoingResponse, resp, 'Internal server error');
  }
}

function getParamsFromPath(path: string): { [key: string]: string } {
  const params: { [key: string]: string } = {};
  const queryString = path.split('?')[1];
  if (queryString) {
    const pairs = queryString.split('&');
    for (const pair of pairs) {
      const [key, value] = pair.split('=');
      if (key && value) {
        params[key] = value;
      }
    }
  }
  return params;
}

function respondWithError(outgoingResponse: OutgoingResponse, resp: ResponseOutparam, message: string) {
  let outgoingBody = outgoingResponse.body();
  {
    let outputStream = outgoingBody.write();
    outputStream.blockingWriteAndFlush(
      new Uint8Array(new TextEncoder().encode(message))
    );
    // @ts-ignore: This is required in order to dispose the stream before we return
    outputStream[Symbol.dispose]();
  }

  outgoingResponse.setStatusCode(500);
  OutgoingBody.finish(outgoingBody, undefined);
  ResponseOutparam.set(resp, { tag: "ok", val: outgoingResponse });
}

export const incomingHandler = {
  handle,
};
