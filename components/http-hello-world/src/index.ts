import {
  IncomingRequest,
  ResponseOutparam,
  OutgoingBody,
  OutgoingResponse,
  Fields
} from "wasi:http/types@0.2.0";
// @ts-expect-error -- these types aren't currently generated by JCO
import { log } from 'wasi:logging/logging';
import { cowsay } from 'cowsayjs';


let mydata: string;

async function asyncOperation(): Promise<string> {
  log('info', 'asyncOperation', `starting operation`);

  log('info', 'asyncOperation', `completed operation`);
  return "Hello, async world!";
}


async function createMydata(): Promise<string> {
  if (!mydata) {
    mydata = "hi , it's the my data"
    log('info', 'asyncOperation', `Mydatacreated from createMydata function`);

    return 'Mydata created ';
  } else {
    return 'Mydata already exists';
  }
}

async function handle(req: IncomingRequest, resp: ResponseOutparam) {
  log('info', 'handle', 'Handling request...');
  const outgoingResponse = new OutgoingResponse(new Fields());

  const pathWithQuery = req.pathWithQuery();
  if (!pathWithQuery) {
    return respondWithError(outgoingResponse, resp, 'Invalid request: pathWithQuery is empty');
  }

  const functionName = getFunctionFromPath(pathWithQuery);

  let message = '';

  try {
    switch (functionName) {
      case 'createMydata':
        message = await createMydata();
        break;
      case 'cowsay':
        message = await cowsayFunction();
        break;
      default:
        message = 'Invalid function';
    }

    let outgoingBody = outgoingResponse.body();
    {
      let outputStream = outgoingBody.write();
      outputStream.blockingWriteAndFlush(
        new Uint8Array(new TextEncoder().encode(message))
      );
      // @ts-ignore: This is required in order to dispose the stream before we return
      outputStream[Symbol.dispose]();
    }

    outgoingResponse.setStatusCode(200);
    OutgoingBody.finish(outgoingBody, undefined);
    ResponseOutparam.set(resp, { tag: "ok", val: outgoingResponse });
    log('info', 'handle', 'Response sent successfully.');
  } catch (err) {
    log('error', 'handle', `Error handling request: ${err}`);
    respondWithError(outgoingResponse, resp, 'Internal server error');
  }
}

function respondWithError(outgoingResponse: OutgoingResponse, resp: ResponseOutparam, message: string) {
  let outgoingBody = outgoingResponse.body();
  {
    let outputStream = outgoingBody.write();
    outputStream.blockingWriteAndFlush(
      new Uint8Array(new TextEncoder().encode(message))
    );
    // @ts-ignore: This is required in order to dispose the stream before we return
    outputStream[Symbol.dispose]();
  }

  outgoingResponse.setStatusCode(500);
  OutgoingBody.finish(outgoingBody, undefined);
  ResponseOutparam.set(resp, { tag: "ok", val: outgoingResponse });
}

function getFunctionFromPath(path: string): string {
  const parts = path.split("=");
  if (parts.length == 2) {
    return parts[1];
  }
  return "world";
}


async function cowsayFunction(): Promise<string> {
  return cowsay({ message: `Hello from Typescript!\nThis is my message!` });
}

export const incomingHandler = {
  handle,
};
