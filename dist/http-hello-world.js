import * as __WEBPACK_EXTERNAL_MODULE_wasi_http_types_0_2_0_12fd8b15__ from "wasi:http/types@0.2.0";
import * as __WEBPACK_EXTERNAL_MODULE_wasi_keyvalue_store_0_2_0_draft_d560164c__ from "wasi:keyvalue/store@0.2.0-draft";
import * as __WEBPACK_EXTERNAL_MODULE_wasi_logging_logging_0a2a8fb1__ from "wasi:logging/logging";
/******/ var __webpack_modules__ = ({

/***/ 340:
/***/ ((module) => {

var x = (y) => {
	var x = {}; __webpack_require__.d(x, y); return x
} 
var y = (x) => (() => (x))
module.exports = __WEBPACK_EXTERNAL_MODULE_wasi_http_types_0_2_0_12fd8b15__;

/***/ }),

/***/ 394:
/***/ ((module) => {

var x = (y) => {
	var x = {}; __webpack_require__.d(x, y); return x
} 
var y = (x) => (() => (x))
module.exports = __WEBPACK_EXTERNAL_MODULE_wasi_keyvalue_store_0_2_0_draft_d560164c__;

/***/ }),

/***/ 283:
/***/ ((module) => {

var x = (y) => {
	var x = {}; __webpack_require__.d(x, y); return x
} 
var y = (x) => (() => (x))
module.exports = __WEBPACK_EXTERNAL_MODULE_wasi_logging_logging_0a2a8fb1__;

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
var exports = __webpack_exports__;

Object.defineProperty(exports, "B", ({ value: true }));
exports.H = void 0;
const types_0_2_0_1 = __webpack_require__(340);
//@ts-expect-error -- these types aren't currently generated by JCO
const logging_1 = __webpack_require__(283);
// @ts-expect-error -- these types aren't currently generated by JCO
const store_0_2_0_draft_1 = __webpack_require__(394);
async function initializeStore() {
    return await (0, store_0_2_0_draft_1.open)('default');
}
async function handle(req, resp) {
    // Start building an outgoing response
    const outgoingResponse = new types_0_2_0_1.OutgoingResponse(new types_0_2_0_1.Fields());
    let outgoingBody = outgoingResponse.body();
    const pathWithQuery = req.pathWithQuery();
    if (!pathWithQuery) {
        return respondWithError(outgoingResponse, resp, 'Invalid request: pathWithQuery is empty');
    }
    const params = getParamsFromPath(pathWithQuery);
    const value = params['value'];
    const key = params['key'];
    if (!value) {
        return respondWithError(outgoingResponse, resp, 'Invalid request: function is not specified');
    }
    (0, logging_1.log)('info', '', `Greeting key ${key}`);
    try {
        const kv = await initializeStore();
        // const newvalue = new Uint8Array([0x48, 0x65, 0x6C, 0x6C, 0x6F]); // Hello
        const encoder = new TextEncoder();
        const newvalue = encoder.encode(value);
        kv.set(key, newvalue); // increment(kv, name, 1);
        const mydata = kv.get(key);
        // Create a stream for the response body
        let outputStream = outgoingBody.write();
        // Write hello world to the response stream
        outputStream.blockingWriteAndFlush(new Uint8Array(new TextEncoder().encode(`Hello x${mydata}, ${key}!\n`)));
        // @ts-ignore: This is required in order to dispose the stream before we return
        outputStream[Symbol.dispose]();
        // Set the status code for the response
        outgoingResponse.setStatusCode(200);
        // Finish the response body
        types_0_2_0_1.OutgoingBody.finish(outgoingBody, undefined);
        // Set the created response
        types_0_2_0_1.ResponseOutparam.set(resp, { tag: 'ok', val: outgoingResponse });
        (0, logging_1.log)('info', 'handle', 'Response sent successfully.');
    }
    catch (error) {
        (0, logging_1.log)('error', 'handle', `Error handling request: ${error}`);
        respondWithError(outgoingResponse, resp, 'Internal server error');
    }
}
function getParamsFromPath(path) {
    const params = {};
    const queryString = path.split('?')[1];
    if (queryString) {
        const pairs = queryString.split('&');
        for (const pair of pairs) {
            const [key, value] = pair.split('=');
            if (key && value) {
                params[key] = value;
            }
        }
    }
    return params;
}
function respondWithError(outgoingResponse, resp, message) {
    let outgoingBody = outgoingResponse.body();
    {
        let outputStream = outgoingBody.write();
        outputStream.blockingWriteAndFlush(new Uint8Array(new TextEncoder().encode(message)));
        // @ts-ignore: This is required in order to dispose the stream before we return
        outputStream[Symbol.dispose]();
    }
    outgoingResponse.setStatusCode(500);
    types_0_2_0_1.OutgoingBody.finish(outgoingBody, undefined);
    types_0_2_0_1.ResponseOutparam.set(resp, { tag: "ok", val: outgoingResponse });
}
exports.H = {
    handle,
};

})();

var __webpack_exports___esModule = __webpack_exports__.B;
var __webpack_exports__incomingHandler = __webpack_exports__.H;
export { __webpack_exports___esModule as __esModule, __webpack_exports__incomingHandler as incomingHandler };
